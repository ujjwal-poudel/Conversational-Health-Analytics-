"""
tts_service.py

Text-to-Speech (TTS) module using the Piper CLI binary.

Purpose
-------
This module converts LLM-generated questions into spoken audio files using the
Piper command-line interface. It is designed for efficiency and reliability,
using subprocess execution to avoid interfering with other ML workloads.

Key Features
------------
1. Piper CLI is invoked through subprocess for isolation and stability.
2. Each TTS request generates a unique WAV file saved on disk.
3. Errors during synthesis or file generation are caught and logged.
4. Uses centralized configuration from config.py
"""

import os
import uuid
import subprocess
from typing import Optional
from app.audio.config import AudioConfig


def synthesize_question_audio(text: str, output_dir: str = None) -> str:
    """
    Synthesizes spoken audio from text using the Piper CLI and returns a WAV file path.

    Parameters
    ----------
    text : str
        The question text produced by the LLM.
    output_dir : str, optional
        Directory to save the audio file. If None, uses default from config.

    Returns
    -------
    str
        The full path to the generated WAV file.
    """

    if not isinstance(text, str) or not text.strip():
        raise ValueError("Input text for TTS must be a non-empty string.")

    filename = f"{uuid.uuid4()}.wav"
    
    # Build absolute paths from current working directory (backend/)
    cwd = os.getcwd()
    
    piper_exe_config = AudioConfig.PIPER_EXECUTABLE
    piper_model_config = AudioConfig.PIPER_MODEL_PATH
    
    if output_dir:
        # Use provided directory
        audio_path = os.path.join(output_dir, filename)
    else:
        # Use config default
        bot_audio_dir_config = AudioConfig.BOT_AUDIO_OUTPUT_DIR
        
        # Sanitize paths: remove 'backend/' prefix if we are already in backend dir
        if cwd.endswith("backend"):
            if bot_audio_dir_config.startswith("backend/"):
                bot_audio_dir_config = bot_audio_dir_config.replace("backend/", "", 1)
                
        audio_path = os.path.join(bot_audio_dir_config, filename)

    if cwd.endswith("backend"):
        if piper_exe_config.startswith("backend/"):
            piper_exe_config = piper_exe_config.replace("backend/", "", 1)
        if piper_model_config.startswith("backend/"):
            piper_model_config = piper_model_config.replace("backend/", "", 1)
    abs_audio_path = os.path.join(cwd, audio_path)
    
    # Ensure the directory exists!
    os.makedirs(os.path.dirname(abs_audio_path), exist_ok=True)
    
    abs_piper_exe = os.path.join(cwd, piper_exe_config)
    abs_model_path = os.path.join(cwd, piper_model_config)
    piper_dir = os.path.dirname(abs_piper_exe)
    
    # Auto-fix: Check if local piper is broken (missing libraries) and venv piper exists
    # This handles the case where the user has a broken manual install but we installed piper-tts
    if not os.path.exists(os.path.join(piper_dir, "libespeak-ng.1.dylib")) and "app/audio/bin/piper" in abs_piper_exe:
        venv_piper = os.path.join(cwd, "../.newvenv/bin/piper")
        if os.path.exists(venv_piper):
            abs_piper_exe = venv_piper
            # Venv piper is a python wrapper, it doesn't need to run from its dir usually, 
            # but let's keep cwd as is or set to venv bin? 
            # Actually, python wrapper handles paths.
            piper_dir = os.path.dirname(abs_piper_exe)

    # Prepare the Piper CLI command with absolute paths
    command = [
        abs_piper_exe,  # Use the absolute path we determined
        "--model", abs_model_path,
        "--output_file", abs_audio_path
    ]
    
    try:
        # Run Piper
        process = subprocess.Popen(
            command,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            cwd=piper_dir  # Run from Piper's directory (or venv bin)
        )

        # Write text to stdin
        stdout, stderr = process.communicate(input=text.encode("utf-8"))

        # Check for Piper errors
        if process.returncode != 0:
            error_msg = stderr.decode("utf-8")
            print(f"[TTS ERROR] Piper failed: {error_msg}")
            raise RuntimeError(f"Piper TTS failed: {error_msg}")

    except Exception as e:
        print(f"[TTS ERROR] Exception running Piper: {e}")
        raise RuntimeError(f"Piper TTS subprocess execution error: {e}")

    # Validate that file exists
    if not os.path.exists(abs_audio_path):
        raise RuntimeError("Output audio file was not generated by Piper.")

    return audio_path  # Return relative path for consistency