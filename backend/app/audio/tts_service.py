"""
tts_service.py

Text-to-Speech (TTS) module using the Piper CLI binary.

Purpose
-------
This module converts LLM-generated questions into spoken audio files using the
Piper command-line interface. It is designed for efficiency and reliability,
using subprocess execution to avoid interfering with other ML workloads.

Key Features
------------
1. Piper CLI is invoked through subprocess for isolation and stability.
2. Each TTS request generates a unique WAV file saved on disk.
3. Errors during synthesis or file generation are caught and logged.
4. Uses centralized configuration from config.py
"""

import os
import uuid
import asyncio
import logging
from typing import Optional

logger = logging.getLogger(__name__)
from app.audio.config import AudioConfig


async def synthesize_question_audio(text: str, output_dir: str = None) -> str:
    """
    Synthesizes spoken audio from text using the Piper CLI and returns a WAV file path.

    Parameters
    ----------
    text : str
        The question text produced by the LLM.
    output_dir : str, optional
        Directory to save the audio file. If None, uses default from config.

    Returns
    -------
    str
        The full path to the generated WAV file.
    """

    if not isinstance(text, str) or not text.strip():
        raise ValueError("Input text for TTS must be a non-empty string.")

    filename = f"{uuid.uuid4()}.wav"
    
    # Build absolute paths from current working directory (backend/)
    cwd = os.getcwd()
    
    piper_exe_config = AudioConfig.PIPER_EXECUTABLE
    piper_model_config = AudioConfig.PIPER_MODEL_PATH
    
    if output_dir:
        # Use provided directory
        audio_path = os.path.join(output_dir, filename)
    else:
        # Use config default
        bot_audio_dir_config = AudioConfig.BOT_AUDIO_OUTPUT_DIR
        
        # Sanitize paths: remove 'backend/' prefix if we are already in backend dir
        if cwd.endswith("backend"):
            if bot_audio_dir_config.startswith("backend/"):
                bot_audio_dir_config = bot_audio_dir_config.replace("backend/", "", 1)
                
        audio_path = os.path.join(bot_audio_dir_config, filename)

    if cwd.endswith("backend"):
        if piper_exe_config.startswith("backend/"):
            piper_exe_config = piper_exe_config.replace("backend/", "", 1)
        if piper_model_config.startswith("backend/"):
            piper_model_config = piper_model_config.replace("backend/", "", 1)
    abs_audio_path = os.path.join(cwd, audio_path)
    
    # Ensure the directory exists!
    os.makedirs(os.path.dirname(abs_audio_path), exist_ok=True)
    
    # Get piper executable - if it's just "piper", use it from PATH (venv)
    # Otherwise construct absolute path
    if piper_exe_config == "piper":
        piper_cmd = "piper"  # Use from PATH (venv)
    elif os.path.isabs(piper_exe_config):
        piper_cmd = piper_exe_config  # Already absolute
    else:
        piper_cmd = os.path.join(cwd, piper_exe_config)  # Make absolute
    
    # Model path - always make absolute if not already
    if os.path.isabs(piper_model_config):
        abs_model_path = piper_model_config
    else:
        abs_model_path = os.path.join(cwd, piper_model_config)

    # Prepare the Piper CLI command
    command = [
        piper_cmd,
        "--model", abs_model_path,
        "--output_file", abs_audio_path
    ]
    
    try:
        # Run Piper subprocess asynchronously
        process = await asyncio.create_subprocess_exec(
            *command,
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        # Write text to stdin and wait for completion
        stdout, stderr = await process.communicate(input=text.encode("utf-8"))

        # Check for Piper errors
        if process.returncode != 0:
            error_msg = stderr.decode("utf-8")
            logger.error("Piper failed: %s", error_msg)
            raise RuntimeError(f"Piper TTS failed: {error_msg}")

    except Exception as e:
        logger.error("Exception running Piper: %s", e)
        raise RuntimeError(f"Piper TTS subprocess execution error: {e}")

    # Validate that file exists
    if not os.path.exists(abs_audio_path):
        raise RuntimeError("Output audio file was not generated by Piper.")

    return audio_path  # Return relative path for consistency